#nullable enable

using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MethodCache.SourceGenerator.Generator.Emit
{
    public sealed partial class MethodCacheGenerator
    {
        // ======================== DI Extensions Emitter ========================
        private static class DIExtensionsEmitter
        {
            internal static string Emit(List<Modeling.MethodCacheGenerator.InterfaceInfo> interfaces)
            {
                // Only count non-generic methods since generic methods don't generate policies
                var hasCachedMethods = interfaces.Any(i => i.CachedMethods.Any(m => !m.Method.IsGenericMethod));

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("#nullable enable");
                sb.AppendLine("using System;");
                sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
                sb.AppendLine("using MethodCache.Core;");
                sb.AppendLine("using MethodCache.Core.Configuration;");
                sb.AppendLine("using MethodCache.Abstractions.Registry;");
                sb.AppendLine("using MethodCache.Core.Configuration.Policies;");
                if (hasCachedMethods)
                {
                    sb.AppendLine("using MethodCache.Generated;");
                }
                sb.AppendLine();
                sb.AppendLine("namespace Microsoft.Extensions.DependencyInjection");
                sb.AppendLine("{");
                sb.AppendLine("    public static class MethodCacheServiceCollectionExtensions");
                sb.AppendLine("    {");

                foreach (var info in interfaces.Where(i => !i.Symbol.IsGenericType))
                {
                    EmitInterfaceExtensions(sb, info, hasCachedMethods);
                }

                sb.AppendLine("    }");
                sb.AppendLine("}");

                return sb.ToString();
            }

            private static void EmitInterfaceExtensions(StringBuilder sb, Modeling.MethodCacheGenerator.InterfaceInfo info, bool hasAnyCachedMethods)
            {
                var interfaceFqn = Utilities.MethodCacheGenerator.Utils.GetFullyQualifiedName(info.Symbol);
                var decoratorFqn = $"{info.Symbol.ContainingNamespace.ToDisplayString()}.{info.Symbol.Name}Decorator";
                var baseName = $"{info.Symbol.Name}WithCaching";

                // Only call AddPolicies if this specific interface has non-generic cached methods
                var interfaceHasCachedMethods = info.CachedMethods.Any(m => !m.Method.IsGenericMethod);

                // Default (Singleton for backward compatibility)
                sb.AppendLine($"        public static IServiceCollection Add{baseName}(");
                sb.AppendLine($"            this IServiceCollection services,");
                sb.AppendLine($"            Func<IServiceProvider, {interfaceFqn}> implementationFactory)");
                sb.AppendLine("        {");
                if (hasAnyCachedMethods && interfaceHasCachedMethods)
                {
                    sb.AppendLine("            GeneratedPolicyRegistrations.AddPolicies(services);");
                }
                sb.AppendLine($"            return services.AddSingleton<{interfaceFqn}>(sp =>");
                sb.AppendLine($"                new {decoratorFqn}(");
                sb.AppendLine("                    implementationFactory(sp),");
                sb.AppendLine("                    sp.GetRequiredService<ICacheManager>(),");
                sb.AppendLine("                    sp.GetRequiredService<IPolicyRegistry>(),");
                sb.AppendLine("                    sp.GetRequiredService<ICacheKeyGenerator>()));");
                sb.AppendLine("        }");
                sb.AppendLine();

                // Explicit lifetime methods
                var lifetimes = new[] { ("Singleton", "AddSingleton"), ("Scoped", "AddScoped"), ("Transient", "AddTransient") };
                foreach (var (suffix, method) in lifetimes)
                {
                    sb.AppendLine($"        public static IServiceCollection Add{baseName}{suffix}(");
                    sb.AppendLine($"            this IServiceCollection services,");
                    sb.AppendLine($"            Func<IServiceProvider, {interfaceFqn}> implementationFactory)");
                    sb.AppendLine("        {");
                    if (hasAnyCachedMethods && interfaceHasCachedMethods)
                    {
                        sb.AppendLine("            GeneratedPolicyRegistrations.AddPolicies(services);");
                    }
                    sb.AppendLine($"            return services.{method}<{interfaceFqn}>(sp =>");
                    sb.AppendLine($"                new {decoratorFqn}(");
                    sb.AppendLine("                    implementationFactory(sp),");
                    sb.AppendLine("                    sp.GetRequiredService<ICacheManager>(),");
                    sb.AppendLine("                    sp.GetRequiredService<IPolicyRegistry>(),");
                    sb.AppendLine("                    sp.GetRequiredService<ICacheKeyGenerator>()));");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                }
            }
        }
    }
}


