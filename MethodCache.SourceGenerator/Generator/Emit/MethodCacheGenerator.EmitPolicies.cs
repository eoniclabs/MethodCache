#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace MethodCache.SourceGenerator
{
    public sealed partial class MethodCacheGenerator
    {
        // ======================== Policy Registrations Emitter ========================
        private static class PolicyRegistrationsEmitter
        {
            private const string PriorityMetadataKey = "priority";
            private const string GroupMetadataKey = "group";

            internal static string Emit(List<InterfaceInfo> interfaces)
            {
                var definitions = BuildDefinitions(interfaces);
                if (definitions.Count == 0)
                {
                    return string.Empty;
                }

                var sb = new StringBuilder();
                AppendHeader(sb);
                AppendGeneratedClass(sb, definitions);
                return sb.ToString();
            }

            private static void AppendHeader(StringBuilder sb)
            {
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("#nullable enable");
                sb.AppendLine("using System;");
                sb.AppendLine("using System.Collections.Generic;");
                sb.AppendLine("using System.Globalization;");
                sb.AppendLine("using System.Threading;");
                sb.AppendLine("using System.Threading.Tasks;");
                sb.AppendLine("using MethodCache.Abstractions.Policies;");
                sb.AppendLine("using MethodCache.Abstractions.Resolution;");
                sb.AppendLine("using MethodCache.Abstractions.Sources;");
                sb.AppendLine("using MethodCache.Core.Runtime;");
                sb.AppendLine("using MethodCache.Core.PolicyPipeline.Model;");
                sb.AppendLine("using MethodCache.Core.PolicyPipeline.Resolution;");
                sb.AppendLine("using MethodCache.Core.Configuration.Surfaces.ConfigFile;");
                sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
                sb.AppendLine();
                sb.AppendLine("namespace MethodCache.Generated");
                sb.AppendLine("{");
            }

            private static void AppendGeneratedClass(StringBuilder sb, List<PolicyDefinition> definitions)
            {
                sb.AppendLine("    internal static class GeneratedPolicyRegistrations");
                sb.AppendLine("    {");
                sb.AppendLine("        public static void AddPolicies(ICollection<PolicySourceRegistration> registrations)");
                sb.AppendLine("        {");
                sb.AppendLine("            if (registrations == null)");
                sb.AppendLine("            {");
                sb.AppendLine("                throw new ArgumentNullException(nameof(registrations));");
                sb.AppendLine("            }");
                sb.AppendLine("            registrations.Add(new PolicySourceRegistration(new GeneratedAttributePolicySource(), 10 /* Attributes */));");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        public static void AddPolicies(IServiceCollection services)");
                sb.AppendLine("        {");
                sb.AppendLine("            if (services == null)");
                sb.AppendLine("            {");
                sb.AppendLine("                throw new ArgumentNullException(nameof(services));");
                sb.AppendLine("            }");
                sb.AppendLine("            services.AddSingleton<PolicySourceRegistration>(_ => new PolicySourceRegistration(new GeneratedAttributePolicySource(), 10 /* Attributes */));");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        private sealed class GeneratedAttributePolicySource : IPolicySource");
                sb.AppendLine("        {");
                sb.AppendLine("            public string SourceId => \"attributes\";");
                sb.AppendLine();
                sb.AppendLine("            public Task<IReadOnlyCollection<PolicySnapshot>> GetSnapshotAsync(CancellationToken cancellationToken = default)");
                sb.AppendLine("            {");
                sb.AppendLine("                cancellationToken.ThrowIfCancellationRequested();");
                sb.AppendLine("                var timestamp = DateTimeOffset.UtcNow;");
                sb.AppendLine($"                var snapshots = new List<PolicySnapshot>({definitions.Count});");
                foreach (var definition in definitions)
                {
                    sb.AppendLine($"                snapshots.Add({definition.SnapshotMethodName}(timestamp));");
                }
                sb.AppendLine("                return Task.FromResult<IReadOnlyCollection<PolicySnapshot>>(snapshots);");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.AppendLine("            public IAsyncEnumerable<PolicyChange> WatchAsync(CancellationToken cancellationToken = default)");
                sb.AppendLine("                => PolicySourceAsyncEnumerable.Empty(cancellationToken);");
                sb.AppendLine("        }");
                sb.AppendLine();

                foreach (var definition in definitions)
                {
                    sb.AppendLine($"        private static PolicySnapshot {definition.SnapshotMethodName}(DateTimeOffset timestamp)");
                    sb.AppendLine("        {");
                    sb.AppendLine("            var policy = CachePolicy.Empty;");
                    sb.AppendLine("            var fields = CachePolicyFields.None;");
                    foreach (var statement in definition.PolicyStatements)
                    {
                        sb.AppendLine("            " + statement);
                    }
                    sb.AppendLine("            policy = CachePolicyMapper.AttachContribution(policy, \"attributes\", fields, timestamp);");
                    sb.AppendLine("            var metadata = new Dictionary<string, string?>(StringComparer.Ordinal)");
                    sb.AppendLine("            {");
                    sb.AppendLine("                [\"priority\"] = \"10\"");
                    sb.AppendLine("            };");
                    foreach (var metadataStatement in definition.MetadataStatements)
                    {
                        sb.AppendLine("            " + metadataStatement);
                    }
                    sb.AppendLine($"            return new PolicySnapshot(\"attributes\", {ToLiteral(definition.MethodId)}, policy, timestamp, metadata);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                }

                sb.AppendLine("    }");
                sb.AppendLine("}");
            }

            private static List<PolicyDefinition> BuildDefinitions(List<InterfaceInfo> interfaces)
            {
                var definitions = new List<PolicyDefinition>();
                var seen = new HashSet<string>(StringComparer.Ordinal);
                var index = 0;

                foreach (var info in interfaces)
                {
                    foreach (var method in info.CachedMethods)
                    {
                        if (method.CacheAttr is null)
                        {
                            continue;
                        }

                        if (method.Method.IsGenericMethod)
                        {
                            continue;
                        }

                        var methodId = Utils.GetMethodId(method.Method);
                        if (!seen.Add(methodId))
                        {
                            continue;
                        }

                        var definition = new PolicyDefinition(methodId, $"BuildSnapshot_{index++}");
                        PopulateFromCacheAttribute(definition, method.CacheAttr);
                        definitions.Add(definition);
                    }
                }

                return definitions;
            }

            private static void PopulateFromCacheAttribute(PolicyDefinition definition, AttributeData cacheAttr)
            {
                if (cacheAttr.ConstructorArguments.Length > 0)
                {
                    var ctorArg = cacheAttr.ConstructorArguments[0];
                    if (ctorArg.Value is string groupName && !string.IsNullOrWhiteSpace(groupName))
                    {
                        definition.MetadataStatements.Add($"metadata[\"{GroupMetadataKey}\"] = {ToLiteral(groupName)};");
                    }
                }

                if (TryGetNamedArgument(cacheAttr, "Duration", out var durationArg) && durationArg.Value is string duration && !string.IsNullOrWhiteSpace(duration))
                {
                    definition.PolicyStatements.Add($"policy = policy with {{ Duration = System.TimeSpan.Parse({ToLiteral(duration)}, System.Globalization.CultureInfo.InvariantCulture) }};");
                    definition.PolicyStatements.Add("fields |= CachePolicyFields.Duration;");
                }

                if (TryGetNamedArgument(cacheAttr, "Tags", out var tagsArg) && tagsArg.Kind == TypedConstantKind.Array)
                {
                    var tags = tagsArg.Values
                        .Select(v => v.Value as string)
                        .Where(s => !string.IsNullOrWhiteSpace(s))
                        .Select(ToLiteral)
                        .ToArray();

                    if (tags.Length > 0)
                    {
                        definition.PolicyStatements.Add($"policy = policy with {{ Tags = new[] {{ {string.Join(", ", tags)} }} }};");
                        definition.PolicyStatements.Add("fields |= CachePolicyFields.Tags;");
                    }
                }

                if (TryGetNamedArgument(cacheAttr, "Version", out var versionArg) && versionArg.Value is int versionValue && versionValue >= 0)
                {
                    definition.PolicyStatements.Add($"policy = policy with {{ Version = {versionValue} }};");
                    definition.PolicyStatements.Add("fields |= CachePolicyFields.Version;");
                }

                if (TryGetNamedArgument(cacheAttr, "KeyGeneratorType", out var keyGeneratorArg) && keyGeneratorArg.Value is INamedTypeSymbol keyGeneratorType)
                {
                    var typeName = Utils.GetFullyQualifiedName(keyGeneratorType);
                    definition.PolicyStatements.Add($"policy = policy with {{ KeyGeneratorType = typeof({typeName}) }};");
                    definition.PolicyStatements.Add("fields |= CachePolicyFields.KeyGenerator;");
                }

                if (TryGetNamedArgument(cacheAttr, "RequireIdempotent", out var idempotentArg) && idempotentArg.Value is bool requireIdempotent && requireIdempotent)
                {
                    definition.PolicyStatements.Add($"policy = policy with {{ RequireIdempotent = {requireIdempotent.ToString().ToLowerInvariant()} }};");
                    definition.PolicyStatements.Add("fields |= CachePolicyFields.RequireIdempotent;");
                }
            }

            private static bool TryGetNamedArgument(AttributeData attribute, string name, out TypedConstant value)
            {
                foreach (var argument in attribute.NamedArguments)
                {
                    if (argument.Key == name)
                    {
                        value = argument.Value;
                        return true;
                    }
                }

                value = default;
                return false;
            }

            private static string ToLiteral(string? value)
            {
                if (value == null)
                {
                    return "null";
                }

                var builder = new StringBuilder(value.Length + 2);
                builder.Append('"');

                foreach (var ch in value)
                {
                    switch (ch)
                    {
                        case '\\':
                            builder.Append("\\\\");
                            break;
                        case '"':
                            builder.Append("\\\"");
                            break;
                        case '\n':
                            builder.Append("\\n");
                            break;
                        case '\r':
                            builder.Append("\\r");
                            break;
                        case '\t':
                            builder.Append("\\t");
                            break;
                        default:
                            if (char.IsControl(ch))
                            {
                                builder.AppendFormat("\\u{0:x4}", (int)ch);
                            }
                            else
                            {
                                builder.Append(ch);
                            }
                            break;
                    }
                }

                builder.Append('"');
                return builder.ToString();
            }

            private sealed class PolicyDefinition
            {
                public PolicyDefinition(string methodId, string snapshotMethodName)
                {
                    MethodId = methodId;
                    SnapshotMethodName = snapshotMethodName;
                }

                public string MethodId { get; }
                public string SnapshotMethodName { get; }
                public List<string> PolicyStatements { get; } = new();
                public List<string> MetadataStatements { get; } = new();
            }
        }
    }
}