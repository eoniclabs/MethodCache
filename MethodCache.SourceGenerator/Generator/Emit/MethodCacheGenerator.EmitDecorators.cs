#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;

namespace MethodCache.SourceGenerator
{
    public sealed partial class MethodCacheGenerator
    {
        // ======================== Decorator Emitter ========================
        private static void EmitTagInvalidation(StringBuilder sb, List<string> staticTags, List<(string template, List<string> paramNames)> dynamicTags, string indent)
        {
            sb.AppendLine($"{indent}var allTags = new List<string>();");

            // Add static tags
            if (staticTags.Any())
            {
                var staticTagsWithoutDynamic = staticTags.Where(t => !DynamicTagParameterRegex.IsMatch(t)).ToList();
                if (staticTagsWithoutDynamic.Any())
                {
                    sb.Append($"{indent}allTags.AddRange(new[] {{ ");
                    sb.Append(string.Join(", ", staticTagsWithoutDynamic.Select(t => $"\"{t}\"")));
                    sb.AppendLine(" });");
                }
            }

            // Add dynamic tags
            foreach (var (template, paramNames) in dynamicTags)
            {
                sb.Append($"{indent}allTags.Add(string.Format(\"{template}\"");
                foreach (var paramName in paramNames)
                {
                    sb.Append($", {paramName}?.ToString() ?? \"null\"");
                }
                sb.AppendLine("));");
            }
        }

        private static class DecoratorEmitter
        {
            internal static string Emit(InterfaceInfo info)
            {
                var sb = new StringBuilder();
                var ns = info.Symbol.ContainingNamespace.ToDisplayString();
                var interfaceFqn = Utils.GetFullyQualifiedName(info.Symbol);
                var className = $"{info.Symbol.Name}Decorator";

                static string GetSimpleInterfaceName(INamedTypeSymbol symbol)
                {
                    return symbol.ToDisplayString(new SymbolDisplayFormat(
                        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                        genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters));
                }


                // File header
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("#nullable enable");
                sb.AppendLine("#pragma warning disable CS8019 // Unnecessary using directive");
                sb.AppendLine("using System;");
                sb.AppendLine("using System.Collections.Generic;");
                sb.AppendLine("using System.Linq;");
                sb.AppendLine("using System.Threading;");
                sb.AppendLine("using System.Threading.Tasks;");
                sb.AppendLine("using MethodCache.Core;");
                sb.AppendLine("using MethodCache.Abstractions.Registry;");
                sb.AppendLine("using MethodCache.Core.Configuration;");
                sb.AppendLine("using MethodCache.Core.Configuration.Policies;");
                sb.AppendLine();
                sb.AppendLine($"namespace {ns}");
                sb.AppendLine("{");

                // Class declaration with generic parameters
                var genericParams = GetClassGenericParameters(info.Symbol);

                // Add XML documentation for generic interface limitations
                if (info.Symbol.IsGenericType)
                {
                    sb.AppendLine("    /// <summary>");
                    sb.AppendLine("    /// Cached implementation of " + GetSimpleInterfaceName(info.Symbol) + ".");
                    sb.AppendLine("    /// </summary>");
                    sb.AppendLine("    /// <remarks>");
                    sb.AppendLine("    /// This generic interface implementation provides type safety and convenience,");
                    sb.AppendLine("    /// but may have slight performance overhead compared to the non-generic interface");
                    sb.AppendLine("    /// for high-throughput scenarios due to runtime type resolution for cache keys.");
                    sb.AppendLine("    /// For maximum performance in critical paths, consider using non-generic interfaces.");
                    sb.AppendLine("    /// </remarks>");
                }

                sb.AppendLine("    [System.CodeDom.Compiler.GeneratedCode(\"MethodCacheGenerator\", \"1.0.0\")]");
                sb.AppendLine("    [System.Diagnostics.DebuggerNonUserCode]");
                sb.AppendLine($"    public class {className}{genericParams} : {GetSimpleInterfaceName(info.Symbol)}");

                // Add generic constraints after class declaration
                EmitGenericConstraints(sb, info.Symbol, "        ");

                sb.AppendLine("    {");

                // Fields
                sb.AppendLine($"        private readonly {interfaceFqn} _decorated;");
                sb.AppendLine("        private readonly ICacheManager _cacheManager;");
                sb.AppendLine("        private readonly IPolicyRegistry _policyRegistry;");
                sb.AppendLine("        private readonly ICacheKeyGenerator _keyGenerator;");
                sb.AppendLine();

                // Constructor
                EmitConstructor(sb, className, interfaceFqn, info.Symbol);

                // Methods
                var allMethods = info.Symbol.GetMembers()
                    .OfType<IMethodSymbol>()
                    .Concat(info.Symbol.AllInterfaces.SelectMany(i => i.GetMembers().OfType<IMethodSymbol>()))
                    .Distinct(SymbolEqualityComparer.Default)
                    .Cast<IMethodSymbol>()
                    .Where(m => m.MethodKind == MethodKind.Ordinary);

                foreach (var method in allMethods)
                {
                    var cached = info.CachedMethods.FirstOrDefault(m => SymbolEqualityComparer.Default.Equals(m.Method, method));
                    var invalidate = info.InvalidateMethods.FirstOrDefault(m => SymbolEqualityComparer.Default.Equals(m.Method, method));

                    if (cached != null)
                        EmitCachedMethod(sb, cached, info.Symbol);
                    else if (invalidate != null)
                        EmitInvalidateMethod(sb, invalidate);
                    else
                        EmitPassthroughMethod(sb, method);
                }

                sb.AppendLine("    }");
                sb.AppendLine("}");
                sb.AppendLine("#pragma warning restore CS8019");

                return sb.ToString();
            }

            private static string GetClassGenericParameters(INamedTypeSymbol symbol)
            {
                if (!symbol.IsGenericType || symbol.TypeParameters.Length == 0)
                    return string.Empty;

                return $"<{string.Join(", ", symbol.TypeParameters.Select(tp => tp.Name))}>";
            }

            private static void EmitGenericConstraints(StringBuilder sb, INamedTypeSymbol symbol, string indent)
            {
                if (!symbol.IsGenericType || symbol.TypeParameters.Length == 0)
                    return;

                foreach (var typeParam in symbol.TypeParameters)
                {
                    var constraints = new List<string>();

                    // Reference type constraint
                    if (typeParam.HasReferenceTypeConstraint)
                        constraints.Add("class");

                    // Value type constraint
                    if (typeParam.HasValueTypeConstraint)
                        constraints.Add("struct");

                    // Notnull constraint (C# 8.0+)
                    if (typeParam.HasNotNullConstraint)
                        constraints.Add("notnull");

                    // Unmanaged constraint (C# 7.3+)
                    if (typeParam.HasUnmanagedTypeConstraint)
                        constraints.Add("unmanaged");

                    // Specific base types or interfaces
                    foreach (var constraintType in typeParam.ConstraintTypes)
                    {
                        constraints.Add(constraintType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat));
                    }

                    // Constructor constraint
                    if (typeParam.HasConstructorConstraint)
                        constraints.Add("new()");

                    if (constraints.Count > 0)
                    {
                        sb.Append(indent);
                        sb.AppendLine($"where {typeParam.Name} : {string.Join(", ", constraints)}");
                    }
                }
            }

            private static void EmitConstructor(StringBuilder sb, string className, string interfaceFqn, INamedTypeSymbol interfaceSymbol)
            {
                // Constructor name should NOT include generic parameters - that's invalid C# syntax
                sb.AppendLine($"        public {className}(");
                sb.AppendLine($"            {interfaceFqn} decorated,");
                sb.AppendLine("            ICacheManager cacheManager,");
                sb.AppendLine("            IPolicyRegistry policyRegistry,");
                sb.AppendLine("            ICacheKeyGenerator keyGenerator)");
                sb.AppendLine("        {");
                sb.AppendLine("            _decorated = decorated ?? throw new ArgumentNullException(nameof(decorated));");
                sb.AppendLine("            _cacheManager = cacheManager ?? throw new ArgumentNullException(nameof(cacheManager));");
                sb.AppendLine("            _policyRegistry = policyRegistry ?? throw new ArgumentNullException(nameof(policyRegistry));");
                sb.AppendLine("            _keyGenerator = keyGenerator ?? throw new ArgumentNullException(nameof(keyGenerator));");
                sb.AppendLine("        }");
                sb.AppendLine();
            }

            private static void EmitCachedMethod(StringBuilder sb, MethodModel model, INamedTypeSymbol interfaceSymbol)
            {
                var method = model.Method;
                var returnType = Utils.GetReturnTypeForSignature(method.ReturnType);
                var methodId = Utils.GetMethodId(method);

                // Method signature
                EmitMethodSignature(sb, method);
                sb.AppendLine("        {");

                // Get cache configuration
                // Build cache key parameters (exclude CancellationToken)
                var keyParams = method.Parameters
                    .Where(p => !Utils.IsCancellationToken(p.Type))
                    .ToList();

                // Generate cache key array
                if (keyParams.Any())
                {
                    sb.Append("            var args = new object[] { ");
                    sb.Append(string.Join(", ", keyParams.Select(p => p.Name)));
                    sb.AppendLine(" };");
                }
                else
                {
                    sb.AppendLine("            var args = new object[] { };");
                }

                sb.AppendLine($"            var policyResult = _policyRegistry.GetPolicy(\"{methodId}\");");
                sb.AppendLine("            var settings = CachePolicyConversion.ToCacheMethodSettings(policyResult.Policy);");

                // Handle different return types
                if (Utils.IsTask(method.ReturnType, out var taskType))
                {
                    EmitTaskCaching(sb, method, taskType!, interfaceSymbol);
                }
                else if (Utils.IsValueTask(method.ReturnType, out var valueTaskType))
                {
                    EmitValueTaskCaching(sb, method, valueTaskType!, interfaceSymbol);
                }
                else
                {
                    EmitSyncCaching(sb, method, returnType, interfaceSymbol);
                }

                sb.AppendLine("        }");
                sb.AppendLine();
            }

            private const string IsIdempotentProperty = "settings.IsIdempotent";

            /// <summary>
            /// Generates cache method name that includes runtime generic type information for generic interfaces
            /// </summary>
            private static string GetCacheMethodName(IMethodSymbol method, INamedTypeSymbol interfaceSymbol)
            {
                // For generic interfaces, we'll generate the name dynamically at runtime 
                // This will be handled in the emit methods by generating appropriate code
                return method.Name; // This will be replaced with dynamic code in emit methods
            }

            private static void EmitTaskCaching(StringBuilder sb, IMethodSymbol method, string innerType, INamedTypeSymbol interfaceSymbol)
            {
                var call = BuildMethodCall(method);

                // Generate dynamic cache method name for generic interfaces
                if (interfaceSymbol.IsGenericType)
                {
                    var baseInterfaceName = interfaceSymbol.Name;
                    var methodName = method.Name;
                    sb.AppendLine($"            var cacheMethodName = \"{baseInterfaceName}<\" + string.Join(\",\", this.GetType().GetGenericArguments().Select(t => t.Name)) + \">.{methodName}\";");
                    sb.AppendLine($"            return _cacheManager.GetOrCreateAsync<{innerType}>(");
                    sb.AppendLine("                cacheMethodName,");
                }
                else
                {
                    sb.AppendLine($"            return _cacheManager.GetOrCreateAsync<{innerType}>(");
                    sb.AppendLine($"                \"{method.Name}\",");
                }
                sb.AppendLine("                args,");
                sb.AppendLine($"                async () => await {call}.ConfigureAwait(false),");
                sb.AppendLine("                settings,");
                sb.AppendLine("                _keyGenerator,");
                sb.AppendLine($"                {IsIdempotentProperty});");
            }

            private static void EmitValueTaskCaching(StringBuilder sb, IMethodSymbol method, string innerType, INamedTypeSymbol interfaceSymbol)
            {
                var call = BuildMethodCall(method);

                // Generate dynamic cache method name for generic interfaces
                if (interfaceSymbol.IsGenericType)
                {
                    var baseInterfaceName = interfaceSymbol.Name;
                    var methodName = method.Name;
                    sb.AppendLine($"            var cacheMethodName = \"{baseInterfaceName}<\" + string.Join(\",\", this.GetType().GetGenericArguments().Select(t => t.Name)) + \">.{methodName}\";");
                    sb.AppendLine($"            var task = _cacheManager.GetOrCreateAsync<{innerType}>(");
                    sb.AppendLine("                cacheMethodName,");
                }
                else
                {
                    sb.AppendLine($"            var task = _cacheManager.GetOrCreateAsync<{innerType}>(");
                    sb.AppendLine($"                \"{method.Name}\",");
                }
                sb.AppendLine("                args,");
                sb.AppendLine($"                async () => await {call}.AsTask().ConfigureAwait(false),");
                sb.AppendLine("                settings,");
                sb.AppendLine("                _keyGenerator,");
                sb.AppendLine($"                {IsIdempotentProperty});");
                sb.AppendLine($"            return new ValueTask<{innerType}>(task);");
            }

            private static void EmitSyncCaching(StringBuilder sb, IMethodSymbol method, string returnType, INamedTypeSymbol interfaceSymbol)
            {
                var call = BuildMethodCall(method);

                // Add warning comment about sync-over-async
                sb.AppendLine("            // WARNING: This is a sync-over-async pattern that may cause deadlocks");
                sb.AppendLine("            // in environments with SynchronizationContext (ASP.NET Framework, WPF, WinForms).");
                sb.AppendLine("            // Consider making the method async to avoid potential issues.");

                // Generate dynamic cache method name for generic interfaces
                if (interfaceSymbol.IsGenericType)
                {
                    var baseInterfaceName = interfaceSymbol.Name;
                    var methodName = method.Name;
                    sb.AppendLine($"            var cacheMethodName = \"{baseInterfaceName}<\" + string.Join(\",\", this.GetType().GetGenericArguments().Select(t => t.Name)) + \">.{methodName}\";");
                    sb.AppendLine($"            return _cacheManager.GetOrCreateAsync<{returnType}>(");
                    sb.AppendLine("                cacheMethodName,");
                }
                else
                {
                    sb.AppendLine($"            return _cacheManager.GetOrCreateAsync<{returnType}>(");
                    sb.AppendLine($"                \"{method.Name}\",");
                }
                sb.AppendLine("                args,");
                sb.AppendLine($"                () => Task.FromResult({call}),");
                sb.AppendLine("                settings,");
                sb.AppendLine("                _keyGenerator,");
                sb.AppendLine($"                {IsIdempotentProperty})");
                sb.AppendLine("                .ConfigureAwait(false).GetAwaiter().GetResult();");
            }

            private static void EmitInvalidateMethod(StringBuilder sb, MethodModel model)
            {
                var method = model.Method;
                var tags = ExtractTags(model.InvalidateAttr!);
                var dynamicTags = ParseDynamicTags(tags, method);

                // For async methods, we need to emit async method signature
                if (Utils.IsTask(method.ReturnType, out _) || Utils.IsValueTask(method.ReturnType, out _))
                {
                    EmitAsyncInvalidateMethodSignature(sb, method);
                }
                else
                {
                    EmitMethodSignature(sb, method);
                }

                sb.AppendLine("        {");

                var call = BuildMethodCall(method);

                // Handle async methods differently
                if (Utils.IsTask(method.ReturnType, out _) || Utils.IsValueTask(method.ReturnType, out _))
                {
                    // For async methods, emit async wrapper
                    EmitAsyncInvalidateMethodBody(sb, method, call, tags, dynamicTags);
                }
                else
                {
                    // For sync methods, emit sync wrapper
                    EmitSyncInvalidateMethodBody(sb, method, call, tags, dynamicTags);
                }

                sb.AppendLine("        }");
                sb.AppendLine();
            }

            private static void EmitAsyncInvalidateMethodSignature(StringBuilder sb, IMethodSymbol method)
            {
                var returnType = Utils.GetReturnTypeForSignature(method.ReturnType);
                var typeParams = method.TypeParameters.Any()
                    ? $"<{string.Join(", ", method.TypeParameters.Select(tp => tp.Name))}>"
                    : string.Empty;

                var parameters = string.Join(", ", method.Parameters.Select(p =>
                {
                    var modifier = p.RefKind switch
                    {
                        RefKind.Ref => "ref ",
                        RefKind.Out => "out ",
                        RefKind.In => "in ",
                        _ => ""
                    };
                    var defaultValue = p.HasExplicitDefaultValue ? $" = {FormatDefaultValue(p.ExplicitDefaultValue)}" : "";
                    return $"{modifier}{Utils.GetReturnTypeForSignature(p.Type)} {p.Name}{defaultValue}";
                }));

                sb.AppendLine($"        public async {returnType} {method.Name}{typeParams}({parameters})");

                // Add generic constraints if any
                foreach (var tp in method.TypeParameters)
                {
                    var constraints = BuildConstraints(tp);
                    if (!string.IsNullOrEmpty(constraints))
                        sb.AppendLine($"            {constraints}");
                }
            }

            private static void EmitAsyncInvalidateMethodBody(StringBuilder sb, IMethodSymbol method, string call, List<string> staticTags, List<(string template, List<string> paramNames)> dynamicTags)
            {
                sb.AppendLine("            try");
                sb.AppendLine("            {");

                if (method.ReturnsVoid || (method.ReturnType is INamedTypeSymbol nt && nt.Name == "Task" && !nt.IsGenericType))
                {
                    sb.AppendLine($"                await {call}.ConfigureAwait(false);");
                }
                else
                {
                    sb.AppendLine($"                var result = await {call}.ConfigureAwait(false);");
                }

                // Invalidate cache AFTER successful execution
                if (staticTags.Any() || dynamicTags.Any())
                {
                    EmitTagInvalidation(sb, staticTags, dynamicTags, "                ");
                    sb.AppendLine("                await _cacheManager.InvalidateByTagsAsync(allTags.ToArray()).ConfigureAwait(false);");
                }

                if (!method.ReturnsVoid && !(method.ReturnType is INamedTypeSymbol nt2 && nt2.Name == "Task" && !nt2.IsGenericType))
                {
                    sb.AppendLine("                return result;");
                }

                sb.AppendLine("            }");
                sb.AppendLine("            catch");
                sb.AppendLine("            {");
                sb.AppendLine("                // Don't invalidate cache on failure");
                sb.AppendLine("                throw;");
                sb.AppendLine("            }");
            }

            private static void EmitSyncInvalidateMethodBody(StringBuilder sb, IMethodSymbol method, string call, List<string> staticTags, List<(string template, List<string> paramNames)> dynamicTags)
            {
                sb.AppendLine("            try");
                sb.AppendLine("            {");

                if (method.ReturnsVoid)
                {
                    sb.AppendLine($"                {call};");
                }
                else
                {
                    sb.AppendLine($"                var result = {call};");
                }

                // Invalidate cache AFTER successful execution
                if (staticTags.Any() || dynamicTags.Any())
                {
                    EmitTagInvalidation(sb, staticTags, dynamicTags, "                ");
                    sb.AppendLine("                _cacheManager.InvalidateByTagsAsync(allTags.ToArray()).GetAwaiter().GetResult();");
                }

                if (!method.ReturnsVoid)
                {
                    sb.AppendLine("                return result;");
                }

                sb.AppendLine("            }");
                sb.AppendLine("            catch");
                sb.AppendLine("            {");
                sb.AppendLine("                // Don't invalidate cache on failure");
                sb.AppendLine("                throw;");
                sb.AppendLine("            }");
            }

            private static void EmitPassthroughMethod(StringBuilder sb, IMethodSymbol method)
            {
                EmitMethodSignature(sb, method);
                sb.AppendLine("        {");

                var call = BuildMethodCall(method);
                if (method.ReturnsVoid)
                    sb.AppendLine($"            {call};");
                else
                    sb.AppendLine($"            return {call};");

                sb.AppendLine("        }");
                sb.AppendLine();
            }


            private static void EmitMethodSignature(StringBuilder sb, IMethodSymbol method)
            {
                var returnType = Utils.GetReturnTypeForSignature(method.ReturnType);
                var typeParams = method.TypeParameters.Any()
                    ? $"<{string.Join(", ", method.TypeParameters.Select(tp => tp.Name))}>"
                    : string.Empty;

                var parameters = string.Join(", ", method.Parameters.Select(p =>
                {
                    var modifier = p.RefKind switch
                    {
                        RefKind.Ref => "ref ",
                        RefKind.Out => "out ",
                        RefKind.In => "in ",
                        _ => ""
                    };
                    var defaultValue = p.HasExplicitDefaultValue ? $" = {FormatDefaultValue(p.ExplicitDefaultValue)}" : "";
                    return $"{modifier}{Utils.GetReturnTypeForSignature(p.Type)} {p.Name}{defaultValue}";
                }));

                sb.AppendLine($"        public {returnType} {method.Name}{typeParams}({parameters})");

                // Add generic constraints if any
                foreach (var tp in method.TypeParameters)
                {
                    var constraints = BuildConstraints(tp);
                    if (!string.IsNullOrEmpty(constraints))
                        sb.AppendLine($"            {constraints}");
                }
            }

            private static string BuildMethodCall(IMethodSymbol method)
            {
                var typeArgs = method.TypeParameters.Any()
                    ? $"<{string.Join(", ", method.TypeParameters.Select(tp => tp.Name))}>"
                    : string.Empty;

                var args = string.Join(", ", method.Parameters.Select(p =>
                {
                    var modifier = p.RefKind switch
                    {
                        RefKind.Ref => "ref ",
                        RefKind.Out => "out ",
                        RefKind.In => "in ",
                        _ => ""
                    };
                    return $"{modifier}{p.Name}";
                }));

                return $"_decorated.{method.Name}{typeArgs}({args})";
            }

            private static string BuildConstraints(ITypeParameterSymbol tp)
            {
                var constraints = new List<string>();

                if (tp.HasReferenceTypeConstraint)
                    constraints.Add("class");
                if (tp.HasValueTypeConstraint)
                    constraints.Add("struct");
                if (tp.HasUnmanagedTypeConstraint)
                    constraints.Add("unmanaged");
                if (tp.HasNotNullConstraint)
                    constraints.Add("notnull");

                constraints.AddRange(tp.ConstraintTypes.Select(ct => Utils.GetFullyQualifiedName(ct)));

                if (tp.HasConstructorConstraint && !tp.HasValueTypeConstraint && !tp.HasUnmanagedTypeConstraint)
                    constraints.Add("new()");

                return constraints.Any()
                    ? $"where {tp.Name} : {string.Join(", ", constraints)}"
                    : string.Empty;
            }

            private static string FormatDefaultValue(object? value)
            {
                return value switch
                {
                    null => "null",
                    string s => $"\"{s}\"",
                    char c => $"'{c}'",
                    bool b => b.ToString().ToLowerInvariant(),
                    _ => value.ToString() ?? "default"
                };
            }
        }

    }
}


