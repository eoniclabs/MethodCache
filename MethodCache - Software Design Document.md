# MethodCache - Software Design Document

**Version**: 6.0 (Revised Architecture)  
**Last Updated**: 2025-07-04

## 1. Overview

MethodCache is a high-performance, production-ready caching library for .NET designed to provide **unobtrusive caching capabilities** without cluttering business logic. It uses compile-time code generation for minimal runtime overhead while offering **comprehensive runtime configuration** for maximum flexibility.

### Design Objectives
- **Unobtrusive**: Add caching with minimal code changes and no business logic pollution
- **Runtime Configurable**: Full control over caching behavior without recompilation
- **High Performance**: Compile-time code generation with minimal runtime overhead
- **Production Ready**: Comprehensive resilience, monitoring, and operational features

## 2. Core Architecture

The architecture is built on three foundational principles: minimal code intrusion, comprehensive runtime configuration, and compile-time performance optimization.

### 2.1. Dual-Phase Configuration System

**Phase 1: Lightweight Attribute Marking**
```csharp
[Cache] // Minimal marking - just indicates method is cacheable
public async Task<User> GetUserAsync(int userId) { ... }

[Cache("user-profile")] // Optional group name for batch configuration
public async Task<UserProfile> GetUserProfileAsync(int userId) { ... }
```

**Phase 2: Rich Runtime Configuration**
```csharp
services.AddMethodCache(config =>
{
    // Type-safe method-specific configuration
    config.ForService<IUserService>()
          .Method(x => x.GetUserAsync(Any<int>()))
          .Duration(TimeSpan.FromHours(1))
          .TagWith("users", ctx => $"user-{ctx.Args[0]}")
          .KeyGenerator<FastHashKeyGenerator>()
          .When(ctx => ctx.Environment.IsProduction());
    
    // Group-based configuration
    config.ForGroup("user-profile")
          .Duration(TimeSpan.FromMinutes(30))
          .TagWith("user-profiles");
    
    // Global defaults
    config.DefaultDuration(TimeSpan.FromMinutes(5))
          .DefaultKeyGenerator<MessagePackKeyGenerator>();
});
```

### 2.2. Configuration Precedence

The system follows a clear precedence hierarchy:

1. **Runtime Dynamic Configuration** (highest priority) - Hot-reloadable settings
2. **Startup Configuration** - Configured via `services.AddMethodCache()`
3. **Attribute Group Configuration** - Settings for methods marked with `[Cache("group")]`
4. **Global Defaults** (lowest priority) - System-wide fallback settings

### 2.3. Interception Mechanism Strategy

The library supports two implementation approaches to cater to different scenarios and performance requirements:

#### **Primary Approach: Roslyn Source Generator**
**Roslyn Source Generator**: Runs during compilation to discover `[Cache]` attributes and generate caching logic.

**Flexible Interception Modes**:
- **Interface-based Decoration**: For classes implementing interfaces, a decorator class is generated
- **Inheritance-based Proxying**: For classes with virtual methods, a child class is generated that overrides methods with caching logic

#### **Alternative Approach: C# 12 Interceptors (Experimental)**
**Call-Site Interceptors**: Uses C# 12 interceptors for precise, high-performance interception at specific call sites.

**Benefits**: More explicit control, potentially better performance, simpler debugging of interception logic.

**Limitations**: Experimental feature, requires .NET 8+ and C# 12+, more complex deployment.

Both approaches share the same configuration system and runtime behavior, differing only in the compile-time code generation strategy.

**Compile-time Method Registry**: The source generator creates a typed registry for runtime configuration:
```csharp
// Auto-generated by source generator
public static class CacheMethodRegistry
{
    public static void RegisterMethods(IMethodCacheConfiguration config)
    {
        config.RegisterMethod<IUserService>(
            x => x.GetUserAsync(Any<int>()),
            "IUserService.GetUserAsync",
            groupName: null
        );
        config.RegisterMethod<IUserService>(
            x => x.GetUserProfileAsync(Any<int>()),
            "IUserService.GetUserProfileAsync", 
            groupName: "user-profile"
        );
    }
}
```

## 3. Key Generation Strategy

The key generation strategy is designed to be secure, deterministic, and performant with multiple options for different scenarios.

### 3.1. Available Key Generators

**MessagePackKeyGenerator (Default)**: Uses MessagePack for deterministic binary serialization with SHA256 hashing for security and consistency.

**FastHashKeyGenerator**: Optimized for high-throughput scenarios, uses simple hash combination for primitive types and falls back to MessagePack for complex objects.

**JsonKeyGenerator**: Human-readable keys for debugging and development environments.

**CustomKeyGenerator**: Interface for application-specific key generation strategies.

### 3.2. Domain Object Integration

**ICacheKeyProvider Interface**: Domain objects can implement this interface to provide optimized key parts:
```csharp
public class User : ICacheKeyProvider
{
    public int Id { get; set; }
    public string CacheKeyPart => $"user-{Id}";
}
```

## 4. Runtime Configuration API

### 4.1. Type-Safe Method Configuration

```csharp
config.ForService<IUserService>()
      .Method(x => x.GetUserAsync(Any<int>()))
      .Duration(ctx => ctx.Environment.IsProduction() 
          ? TimeSpan.FromHours(1) 
          : TimeSpan.FromMinutes(5))
      .TagWith("users", ctx => $"user-{ctx.GetArg<int>(0)}")
      .Version(2) // For cache versioning
      .KeyGenerator<CustomUserKeyGenerator>()
      .When(ctx => ShouldCacheUser(ctx.GetArg<int>(0)))
      .OnHit(ctx => LogCacheHit(ctx.MethodName))
      .OnMiss(ctx => LogCacheMiss(ctx.MethodName));
```

### 4.2. Dynamic Configuration Updates

```csharp
public interface ICacheConfigurationService
{
    Task UpdateMethodConfigurationAsync(string methodId, CacheMethodSettings settings);
    Task EnableCachingAsync(string methodId, bool enabled);
    Task UpdateGlobalSettingsAsync(GlobalCacheSettings settings);
    Task InvalidateConfigurationCacheAsync();
}
```

### 4.3. Context-Aware Configuration

The configuration system provides rich context for decision-making:
```csharp
public class CacheExecutionContext
{
    public string MethodName { get; }
    public Type ServiceType { get; }
    public object[] Args { get; }
    public IServiceProvider Services { get; }
    public CancellationToken CancellationToken { get; }
    
    public T GetArg<T>(int index);
    public T GetArg<T>(string parameterName);
    public T GetService<T>();
}
```

## 5. Advanced Features

### 5.1. Tag-Based Invalidation

**Flexible Tagging System**:
```csharp
config.TagWith("users") // Static tag
      .TagWith(ctx => $"user-{ctx.GetArg<int>("userId")}") // Dynamic tag
      .TagWith(ctx => ctx.GetArg<User>("user").GetCacheKeyPart()); // Object-based tag
```

**Invalidation Methods**:
```csharp
// Attribute-based invalidation
[CacheInvalidate(Tags = new[] { "users" })]
public async Task UpdateUserAsync(User user) { ... }

// Programmatic invalidation
await cacheManager.InvalidateByTagsAsync("users", $"user-{userId}");
```

### 5.2. Concurrency & Memory Management

**Cache Stampede Prevention**: Uses `ConcurrentDictionary<string, Lazy<Task>>` with automatic cleanup of completed tasks to prevent memory leaks.

**Idempotency Enforcement**: The system requires explicit acknowledgment that cached methods are idempotent:
```csharp
[Cache(RequireIdempotent = true)] // Explicit requirement
public async Task<User> GetUserAsync(int userId) { ... }
```

### 5.3. Versioning Strategy

**Automatic Version Integration**: Cache keys automatically include version information to handle breaking changes:
```csharp
config.Version(2) // Version 2 keys won't match Version 1 cached data
```

## 6. Production Readiness

### 6.1. Resilience and Error Handling

**Granular Circuit Breaker**: Implemented per-provider instance and per-operation type (read vs. write) with configurable thresholds.

**Fail-Safe Logic**: All cache failures are logged and treated as cache misses, ensuring application availability.

**Timeout Management**: Configurable timeouts for cache operations to prevent blocking application threads.

### 6.2. Monitoring and Observability

**ICacheMetricsProvider Interface**: Comprehensive metrics collection for:
- Hit/miss ratios per method
- Cache operation latencies
- Error rates and circuit breaker states
- Memory usage and key distribution

**Structured Logging**: Integration with Microsoft.Extensions.Logging with configurable log levels and secure parameter redaction.

**Health Checks**: Built-in health check providers for monitoring cache provider availability.

### 6.3. Security Considerations

**Secure Telemetry**: Automatic parameter redaction in logs with configurable sensitive data detection.

**Key Security**: Default hash-based key generation mitigates key injection attacks.

**Data Isolation**: Clear guidance on data-at-rest encryption and multi-tenant cache isolation.

### 6.4. Async Best Practices

**Cancellation Token Propagation**: All generated code properly propagates cancellation tokens.

**ConfigureAwait(false)**: All internal awaits use `ConfigureAwait(false)` to prevent deadlocks.

**ValueTask Support**: Proper handling of both `Task<T>` and `ValueTask<T>` return types.

## 7. Testing and Development

### 7.1. Testing Support

**NoOpCacheProvider**: Built-in provider for disabling caching in tests.

**MockCacheProvider**: Test provider with configurable hit/miss behavior.

**Configuration Testing**: Utilities for validating cache configuration without executing cached methods.

### 7.2. Development Experience

**IntelliSense Support**: Full type safety and autocompletion in configuration.

**Compile-time Validation**: Source generator validates attribute usage and generates warnings for potential issues.

**Development Mode**: Special configuration mode with enhanced logging and validation for development environments.

## 8. Operational Guidance

### 8.1. Cache Warming

**IHostedService Pattern**: Provided patterns for cache warming during application startup:
```csharp
public class CacheWarmupService : IHostedService
{
    public async Task StartAsync(CancellationToken cancellationToken)
    {
        await cacheWarmer.WarmMethodAsync<IUserService>(x => x.GetActiveUsersAsync());
    }
}
```

### 8.2. Resource Management

**Memory Pressure Handling**: Integration with .NET's memory pressure APIs for automatic cache eviction.

**Distributed Cache Consistency**: Clear documentation of consistency models and recommended patterns for distributed scenarios.

**Performance Monitoring**: Built-in performance counters and integration guidance for APM tools.

## 9. Project Structure

**MethodCache.Core**: Central library containing interfaces, attributes, default providers, and configuration system.

**MethodCache.SourceGenerator**: Roslyn Source Generator for compile-time code generation (primary approach).

**MethodCache.Interceptors**: C# 12 Interceptors-based implementation for precise call-site control (experimental).

**MethodCache.Providers.***: Optional packages for distributed cache providers (Redis, SqlServer, etc.).

**MethodCache.Extensions.***: Optional packages for framework integrations (AspNetCore, MediatR, etc.).

**Testing & Samples**: Comprehensive test suite and sample applications demonstrating various usage patterns.

### 9.1. Implementation Strategy Comparison

#### **MethodCache.SourceGenerator (Recommended)**
- **Use Case**: Standard caching scenarios, production applications
- **Benefits**: Mature, stable, easy distribution, universal method coverage
- **Approach**: Generates decorators/proxies for all methods marked with `[Cache]`

```csharp
[Cache]
public async Task<User> GetUserAsync(int userId) { ... }
// Source generator creates decorator that wraps ALL calls to this method
```

#### **MethodCache.Interceptors (Experimental)**
- **Use Case**: High-performance scenarios, specific call-site optimization
- **Benefits**: Precise control, potentially better performance, explicit interception
- **Approach**: Intercepts specific call sites with generated interceptor methods

```csharp
[Cache]
public async Task<User> GetUserAsync(int userId) { ... }

// Usage with interceptor attributes
[InterceptsLocation("file.cs", 10, 25)] // Specific call site
public static async Task<User> GetUserAsync_Cached(this IUserService service, int userId)
{
    // Generated caching logic for this specific call
}
```

#### **Package Selection Guidance**

**Choose SourceGenerator when**:
- Building production applications
- Need universal method caching
- Want simple NuGet package integration
- Prefer mature, stable tooling

**Choose Interceptors when**:
- Need experimental cutting-edge performance
- Want precise call-site control
- Can accept preview feature limitations
- Working in .NET 8+ with C# 12+

## 10. Migration and Adoption

### 10.1. Gradual Adoption Strategy

1. **Phase 1**: Add `[Cache]` attributes to methods
2. **Phase 2**: Configure basic runtime settings
3. **Phase 3**: Implement advanced features (tagging, versioning, custom providers)
4. **Phase 4**: Add monitoring and operational tooling

### 10.2. Integration Patterns

**ASP.NET Core**: Built-in integration with dependency injection and configuration systems.

**Background Services**: Patterns for caching in hosted services and background workers.

**MediatR Integration**: Optional package for caching MediatR handlers and behaviors.

## 11. Design Philosophy

This library prioritizes **developer experience** and **operational simplicity** while maintaining **high performance**. The dual-phase configuration approach allows developers to start simple with just attributes and gradually adopt more sophisticated runtime configuration as their needs evolve.

The compile-time source generation approach was chosen to achieve zero-runtime-dependency performance while providing rich development-time tooling and validation. This ensures that caching truly remains unobtrusive to business logic while providing enterprise-grade operational capabilities.